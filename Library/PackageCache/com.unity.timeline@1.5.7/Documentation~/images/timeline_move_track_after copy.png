
struct __strip_signature<_Rp (_Gp::*) (_Ap...)> { using type = _Rp(_Ap...); };
template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) const> { using type = _Rp(_Ap...); };
template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) volatile> { using type = _Rp(_Ap...); };
template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) const volatile> { using type = _Rp(_Ap...); };

template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) &> { using type = _Rp(_Ap...); };
template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) const &> { using type = _Rp(_Ap...); };
template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) volatile &> { using type = _Rp(_Ap...); };
template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) const volatile &> { using type = _Rp(_Ap...); };

template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) noexcept> { using type = _Rp(_Ap...); };
template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) const noexcept> { using type = _Rp(_Ap...); };
template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) volatile noexcept> { using type = _Rp(_Ap...); };
template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) const volatile noexcept> { using type = _Rp(_Ap...); };

template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) & noexcept> { using type = _Rp(_Ap...); };
template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) const & noexcept> { using type = _Rp(_Ap...); };
template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) volatile & noexcept> { using type = _Rp(_Ap...); };
template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) const volatile & noexcept> { using type = _Rp(_Ap...); };

template<class _Fp, class _Stripped = typename __strip_signature<decltype(&_Fp::operator())>::type>
function(_Fp) -> function<_Stripped>;
#endif // !_LIBCPP_HAS_NO_DEDUCTION_GUIDES

template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>::function(const function& __f) : __f_(__f.__f_) {}

#if _LIBCPP_STD_VER <= 14
template<class _Rp, class ..._ArgTypes>
template <class _Alloc>
function<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc&,
                                     const function& __f) : __f_(__f.__f_) {}
#endif

template <class _Rp, class... _ArgTypes>
function<_Rp(_ArgTypes...)>::function(function&& __f) _NOEXCEPT
    : __f_(_VSTD::move(__f.__f_)) {}

#if _LIBCPP_STD_VER <= 14
template<class _Rp, class ..._ArgTypes>
template <class _Alloc>
function<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc&,
                                      function&& __f)
    : __f_(_VSTD::move(__f.__f_)) {}
#endif

template <class _Rp, class... _ArgTypes>
template <class _Fp, class>
function<_Rp(_ArgTypes...)>::function(_Fp __f) : __f_(_VSTD::move(__f)) {}

#if _LIBCPP_STD_VER <= 14
template <class _Rp, class... _ArgTypes>
template <class _Fp, class _Alloc, class>
function<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc& __a,
                                      _Fp __f)
    : __f_(_VSTD::move(__f), __a) {}
#endif

template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>&
function<_Rp(_ArgTypes...)>::operator=(const function& __f)
{
    function(__f).swap(*this);
    return *this;
}

template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>&
function<_Rp(_ArgTypes...)>::operator=(function&& __f) _NOEXCEPT
{
    __f_ = std::move(__f.__f_);
    return *this;
}

template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>&
function<_Rp(_ArgTypes...)>::operator=(nullptr_t) _NOEXCEPT
{
    __f_ = nullptr;
    return *this;
}

template<class _Rp, class ..._ArgTypes>
template <class _Fp, class>
function<_Rp(_ArgTypes...)>&
function<_Rp(_ArgTypes...)>::operator=(_Fp&& __f)
{
    function(_VSTD::forward<_Fp>(__f)).swap(*this);
    return *this;
}

template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>::~function() {}

template<class _Rp, class ..._ArgTypes>
void
function<_Rp(_ArgTypes...)>::swap(function& __f) _NOEXCEPT
{
    __f_.swap(__f.__f_);
}

template<class _Rp, class ..._ArgTypes>
_Rp
function<_Rp(_ArgTypes...)>::operator()(_ArgTypes... __arg) const
{
    return __f_(_VSTD::forward<_ArgTypes>(__arg)...);
}

#ifndef _LIBCPP_NO_RTTI

template<class _Rp, class ..._ArgTypes>
const std::type_info&
function<_Rp(_ArgTypes...)>::target_type() const _NOEXCEPT
{
    return __f_.target_type();
}

template<class _Rp, class ..._ArgTypes>
template <typename _Tp>
_Tp*
function<_Rp(_ArgTypes...)>::target() _NOEXCEPT
{
    return (_Tp*)(__f_.template target<_Tp>());
}

template<class _Rp, class ..._ArgTypes>
template <typename _Tp>
const _Tp*
function<_Rp(_ArgTypes...)>::target() const _NOEXCEPT
{
    return __f_.template target<_Tp>();
}

#endif  // _LIBCPP_NO_RTTI

template <class _Rp, class... _ArgTypes>
inline _LIBCPP_INLINE_VISIBILITY
bool
operator==(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) _NOEXCEPT {return !__f;}

template <class _Rp, class... _ArgTypes>
inline _LIBCPP_INLINE_VISIBILITY
bool
operator==(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) _NOEXCEPT {return !__f;}

template <class _Rp, class... _ArgTypes>
inline _LIBCPP_INLINE_VISIBILITY
bool
operator!=(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) _NOEXCEPT {return (bool)__f;}

template <class _Rp, class... _ArgTypes>
inline _LIBCPP_INLINE_VISIBILITY
bool
operator!=(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) _NOEXCEPT {return (bool)__f;}

template <class _Rp, class... _ArgTypes>
inline _LIBCPP_INLINE_VISIBILITY
void
swap(function<_Rp(_ArgTypes...)>& __x, function<_Rp(_ArgTypes...)>& __y) _NOEXCEPT
{return __x.swap(__y);}

#else // _LIBCPP_CXX03_LANG

#include <__functional_03>

#endif

////////////////////////////////////////////////////////////////////////////////
//                                  BIND
//==============================================================================

template<class _Tp> struct __is_bind_expression : public false_type {};
template<class _Tp> struct _LIBCPP_TEMPLATE_VIS is_bind_expression
    : public __is_bind_expression<typename remove_cv<_Tp>::type> {};

#if _LIBCPP_STD_VER > 14
template <class _Tp>
_LIBCPP_INLINE_VAR constexpr size_t is_bind_expression_v = is_bind_expression<_Tp>::value;
#endif

template<class _Tp> struct __is_placeholder : public integral_constant<int, 0> {};
template<class _Tp> struct _LIBCPP_TEMPLATE_VIS is_placeholder
    : public __is_placeholder<typename remove_cv<_Tp>::type> {};

#if _LIBCPP_STD_VER > 14
template <class _Tp>
_LIBCPP_INLINE_VAR constexpr size_t is_placeholder_v = is_placeholder<_Tp>::value;
#endif

namespace placeholders
{

template <int _Np> struct __ph {};

#if defined(_LIBCPP_CXX03_LANG) || defined(_LIBCPP_BUILDING_LIBRARY)
_LIBCPP_FUNC_VIS extern const __ph<1>   _1;
_LIBCPP_FUNC_VIS extern const __ph<2>   _2;
_LIBCPP_FUNC_VIS extern const __ph<3>   _3;
_LIBCPP_FUNC_VIS extern const __ph<4>   _4;
_LIBCPP_FUNC_VIS extern const __ph<5>   _5;
_LIBCPP_FUNC_VIS extern const __ph<6>   _6;
_LIBCPP_FUNC_VIS extern const __ph<7>   _7;
_LIBCPP_FUNC_VIS extern const __ph<8>   _8;
_LIBCPP_FUNC_VIS extern const __ph<9>   _9;
_LIBCPP_FUNC_VIS extern const __ph<10> _10;
#else
/* _LIBCPP_INLINE_VAR */ constexpr __ph<1>   _1{};
/* _LIBCPP_INLINE_VAR */ constexpr __ph<2>   _2{};
/* _LIBCPP_INLINE_VAR */ constexpr __ph<3>   _3{};
/* _LIBCPP_INLINE_VAR */ constexpr __ph<4>   _4{};
/* _LIBCPP_INLINE_VAR */ constexpr __ph<5>   _5{};
/* _LIBCPP_INLINE_VAR */ constexpr __ph<6>   _6{};
/* _LIBCPP_INLINE_VAR */ constexpr __ph<7>   _7{};
/* _LIBCPP_INLINE_VAR */ constexpr __ph<8>   _8{};
/* _LIBCPP_INLINE_VAR */ constexpr __ph<9>   _9{};
/* _LIBCPP_INLINE_VAR */ constexpr __ph<10> _10{};
#endif // defined(_LIBCPP_CXX03_LANG) || defined(_LIBCPP_BUILDING_LIBRARY)

}  // placeholders

template<int _Np>
struct __is_placeholder<placeholders::__ph<_Np> >
    : public integral_constant<int, _Np> {};


#ifndef _LIBCPP_CXX03_LANG

template <class _Tp, class _Uj>
inline _LIBCPP_INLINE_VISIBILITY
_Tp&
__mu(reference_wrapper<_Tp> __t, _Uj&)
{
    return __t.get();
}

template <class _Ti, class ..._Uj, size_t ..._Indx>
inline _LIBCPP_INLINE_VISIBILITY
typename __invoke_of<_Ti&, _Uj...>::type
__mu_expand(_Ti& __ti, tuple<_Uj...>& __uj, __tuple_indices<_Indx...>)
{
    return __ti(_VSTD::forward<_Uj>(_VSTD::get<_Indx>(__uj))...);
}

template <class _Ti, class ..._Uj>
inline _LIBCPP_INLINE_VISIBILITY
typename _EnableIf
<
    is_bind_expression<_Ti>::value,
    __invoke_of<_Ti&, _Uj...>
>::type
__mu(_Ti& __ti, tuple<_Uj...>& __uj)
{
    typedef typename __make_tuple_indices<sizeof...(_Uj)>::type __indices;
    return  __mu_expand(__ti, __uj, __indices());
}

template <bool IsPh, class _Ti, class _Uj>
struct __mu_return2 {};

template <class _Ti, class _Uj>
struct __mu_return2<true, _Ti, _Uj>
{
    typedef typename tuple_element<is_placeholder<_Ti>::value - 1, _Uj>::type type;
};

template <class _Ti, class _Uj>
inline _LIBCPP_INLINE_VISIBILITY
typename enable_if
<
    0 < is_placeholder<_Ti>::value,
    typename __mu_return2<0 < is_placeholder<_Ti>::value, _Ti, _Uj>::type
>::type
__mu(_Ti&, _Uj& __uj)
{
    const size_t _Indx = is_placeholder<_Ti>::value - 1;
    return _VSTD::forward<typename tuple_element<_Indx, _Uj>::type>(_VSTD::get<_Indx>(__uj));
}

template <class _Ti, class _Uj>
inline _LIBCPP_INLINE_VISIBILITY
typename enable_if
<
    !is_bind_expression<_Ti>::value &&
    is_placeholder<_Ti>::value == 0 &&
    !__is_reference_wrapper<_Ti>::value,
    _Ti&
>::type
__mu(_Ti& __ti, _Uj&)
{
    return __ti;
}

template <class _Ti, bool IsReferenceWrapper, bool IsBindEx, bool IsPh,
          class _TupleUj>
struct __mu_return_impl;

template <bool _Invokable, class _Ti, class ..._Uj>
struct __mu_return_invokable  // false
{
    typedef __nat type;
};

template <class _Ti, class ..._Uj>
struct __mu_return_invokable<true, _Ti, _Uj...>
{
    typedef typename __invoke_of<_Ti&, _Uj...>::type type;
};

template <class _Ti, class ..._Uj>
struct __mu_return_impl<_Ti, false, true, false, tuple<_Uj...> >
    : public __mu_return_invokable<__invokable<_Ti&, _Uj...>::value, _Ti, _Uj...>
{
};

template <class _Ti, class _TupleUj>
struct __mu_return_impl<_Ti, false, false, true, _TupleUj>
{
    typedef typename tuple_element<is_placeholder<_Ti>::value - 1,
                                   _TupleUj>::type&& type;
};

template <class _Ti, class _TupleUj>
struct __mu_return_impl<_Ti, true, false, false, _TupleUj>
{
    typedef typename _Ti::type& type;
};

template <class _Ti, class _TupleUj>
struct __mu_return_impl<_Ti, false, false, false, _TupleUj>
{
    typedef _Ti& type;
};

template <class _Ti, class _TupleUj>
struct __mu_return
    : public __mu_return_impl<_Ti,
                              __is_reference_wrapper<_Ti>::value,
                              is_bind_expression<_Ti>::value,
                              0 < is_placeholder<_Ti>::value &&
                              is_placeholder<_Ti>::value <= tuple_size<_TupleUj>::value,
                              _TupleUj>
{
};

template <class _Fp, class _BoundArgs, class _TupleUj>
struct __is_valid_bind_return
{
    static const bool value = false;
};

template <class _Fp, class ..._BoundArgs, class _TupleUj>
struct __is_valid_bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj>
{
    static const bool value = __invokable<_Fp,
                    typename __mu_return<_BoundArgs, _TupleUj>::type...>::value;
};

template <class _Fp, class ..._BoundArgs, class _TupleUj>
struct __is_valid_bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj>
{
    static const bool value = __invokable<_Fp,
                    typename __mu_return<const _BoundArgs, _TupleUj>::type...>::value;
};

template <class _Fp, class _BoundArgs, class _TupleUj,
          bool = __is_valid_bind_return<_Fp, _BoundArgs, _TupleUj>::value>
struct __bind_return;

template <class _Fp, class ..._BoundArgs, class _TupleUj>
struct __bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj, true>
{
    typedef typename __invoke_of
    <
        _Fp&,
        typename __mu_return
        <
            _BoundArgs,
            _TupleUj
        >::type...
    >::type type;
};

template <class _Fp, class ..._BoundArgs, class _TupleUj>
struct __bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj, true>
{
    typedef typename __invoke_of
    <
        _Fp&,
        typename __mu_return
        <
            const _BoundArgs,
            _TupleUj
        >::type...
    >::type type;
};

template <class _Fp, class _BoundArgs, size_t ..._Indx, class _Args>
inline _LIBCPP_INLINE_VISIBILITY
typename __bind_return<_Fp, _BoundArgs, _Args>::type
__apply_functor(_Fp& __f, _BoundArgs& __bound_args, __tuple_indices<_Indx...>,
                _Args&& __args)
{
    return _VSTD::__invoke(__f, _VSTD::__mu(_VSTD::get<_Indx>(__bound_args), __args)...);
}

template<class _Fp, class ..._BoundArgs>
class __bind
    : public __weak_result_type<typename decay<_Fp>::type>
{
protected:
    typedef typename decay<_Fp>::type _Fd;
    typedef tuple<typename decay<_BoundArgs>::type...> _Td;
private:
    _Fd __f_;
    _Td __bound_args_;

    typedef typename __make_tuple_indices<sizeof...(_BoundArgs)>::type __indices;
public:
    template <class _Gp, class ..._BA,
              class = typename enable_if
                               <
                                  is_constructible<_Fd, _Gp>::value &&
                                  !is_same<typename remove_reference<_Gp>::type,
                                           __bind>::value
                               >::type>
      _LIBCPP_INLINE_VISIBILITY
      explicit __bind(_Gp&& __f, _BA&& ...__bound_args)
        : __f_(_VSTD::forward<_Gp>(__f)),
          __bound_args_(_VSTD::forward<_BA>(__bound_args)...) {}

    template <class ..._Args>
        _LIBCPP_INLINE_VISIBILITY
        typename __bind_return<_Fd, _Td, tuple<_Args&&...> >::type
        operator()(_Args&& ...__args)
        {
            return _VSTD::__apply_functor(__f_, __bound_args_, __indices(),
                                  tuple<_Args&&...>(_VSTD::forward<_Args>(__args)...));
        }

    template <class ..._Args>
        _LIBCPP_INLINE_VISIBILITY
        typename __bind_return<const _Fd, const _Td, tuple<_Args&&...> >::type
        operator()(_Args&& ...__args) const
        {
            return _VSTD::__apply_functor(__f_, __bound_args_, __indices(),
                                   tuple<_Args&&...>(_VSTD::forward<_Args>(__args)...));
        }
};

template<class _Fp, class ..._BoundArgs>
struct __is_bind_expression<__bind<_Fp, _BoundArgs...> > : public true_type {};

template<class _Rp, class _Fp, class ..._BoundArgs>
class __bind_r
    : public __bind<_Fp, _BoundArgs...>
{
    typedef __bind<_Fp, _BoundArgs...> base;
    typedef typename base::_Fd _Fd;
    typedef typename base::_Td _Td;
public:
    typedef _Rp result_type;


    template <class _Gp, class ..._BA,
              class = typename enable_if
                               <
                                  is_constructible<_Fd, _Gp>::value &&
                                  !is_same<typename remove_reference<_Gp>::type,
                                           __bind_r>::value
                               >::type>
      _LIBCPP_INLINE_VISIBILITY
      explicit __bind_r(_Gp&& __f, _BA&& ...__bound_args)
        : base(_VSTD::forward<_Gp>(__f),
               _VSTD::forward<_BA>(__bound_args)...) {}

    template <class ..._Args>
        _LIBCPP_INLINE_VISIBILITY
        typename enable_if
        <
            is_convertible<typename __bind_return<_Fd, _Td, tuple<_Args&&...> >::type,
                           result_type>::value || is_void<_Rp>::value,
            result_type
        >::type
        operator()(_Args&& ...__args)
        {
            typedef __invoke_void_return_wrapper<_Rp> _Invoker;
            return _Invoker::__call(static_cast<base&>(*this), _VSTD::forward<_Args>(__args)...);
        }

    template <class ..._Args>
        _LIBCPP_INLINE_VISIBILITY
        typename enable_if
        <
            is_convertible<typename __bind_return<const _Fd, const _Td, tuple<_Args&&...> >::type,
                           result_type>::value || is_void<_Rp>::value,
            result_type
        >::type
        operator()(_Args&& ...__args) const
        {
            typedef __invoke_void_return_wrapper<_Rp> _Invoker;
            return _Invoker::__call(static_cast<base const&>(*this), _VSTD::forward<_Args>(__args)...);
        }
};

template<class _Rp, class _Fp, class ..._BoundArgs>
struct __is_bind_expression<__bind_r<_Rp, _Fp, _BoundArgs...> > : public true_type {};

template<class _Fp, class ..._BoundArgs>
inline _LIBCPP_INLINE_VISIBILITY
__bind<_Fp, _BoundArgs...>
bind(_Fp&& __f, _BoundArgs&&... __bound_args)
{
    typedef __bind<_Fp, _BoundArgs...> type;
    return type(_VSTD::forward<_Fp>(__f), _VSTD::forward<_BoundArgs>(__bound_args)...);
}

template<class _Rp, class _Fp, class ..._BoundArgs>
inline _LIBCPP_INLINE_VISIBILITY
__bind_r<_Rp, _Fp, _BoundArgs...>
bind(_Fp&& __f, _BoundArgs&&... __bound_args)
{
    typedef __bind_r<_Rp, _Fp, _BoundArgs...> type;
    return type(_VSTD::forward<_Fp>(__f), _VSTD::forward<_BoundArgs>(__bound_args)...);
}

#endif  // _LIBCPP_CXX03_LANG

#if _LIBCPP_STD_VER > 14

template <class _Fn, class ..._Args>
invoke_result_t<_Fn, _Args...>
invoke(_Fn&& __f, _Args&&... __args)
    noexcept(is_nothrow_invocable_v<_Fn, _Args...>)
{
    return _VSTD::__invoke(_VSTD::forward<_Fn>(__f), _VSTD::forward<_Args>(__args)...);
}

template <class _DecayFunc>
class _LIBCPP_TEMPLATE_VIS __not_fn_imp {
  _DecayFunc __fd;

public:
    __not_fn_imp() = delete;

    template <class ..._Args>
    _LIBCPP_INLINE_VISIBILITY
    auto operator()(_Args&& ...__args) &
            noexcept(noexcept(!_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...)))
        -> decltype(          !_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...))
        { return              !_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...); }

    template <class ..._Args>
    _LIBCPP_INLINE_VISIBILITY
    auto operator()(_Args&& ...__args) &&
            noexcept(noexcept(!_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...)))
        -> decltype(          !_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...))
        { return              !_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...); }

    template <class ..._Args>
    _LIBCPP_INLINE_VISIBILITY
    auto operator()(_Args&& ...__args) const&
            noexcept(noexcept(!_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...)))
        -> decltype(          !_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...))
        { return              !_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...); }


    template <class ..._Args>
    _LIBCPP_INLINE_VISIBILITY
    auto operator()(_Args&& ...__args) const&&
            noexcept(noexcept(!_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...)))
        -> decltype(          !_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...))
        { return              !_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...); }

private:
    template <class _RawFunc,
              class = enable_if_t<!is_same<decay_t<_RawFunc>, __not_fn_imp>::value>>
    _LIBCPP_INLINE_VISIBILITY
    explicit __not_fn_imp(_RawFunc&& __rf)
        : __fd(_VSTD::forward<_RawFunc>(__rf)) {}

    template <class _RawFunc>
    friend inline _LIBCPP_INLINE_VISIBILITY
    __not_fn_imp<decay_t<_RawFunc>> not_fn(_RawFunc&&);
};

template <class _RawFunc>
inline _LIBCPP_INLINE_VISIBILITY
__not_fn_imp<decay_t<_RawFunc>> not_fn(_RawFunc&& __fn) {
    return __not_fn_imp<decay_t<_RawFunc>>(_VSTD::forward<_RawFunc>(__fn));
}

#endif

// struct hash<T*> in <memory>

template <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>
pair<_ForwardIterator1, _ForwardIterator1> _LIBCPP_CONSTEXPR_AFTER_CXX11
__search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,
         forward_iterator_tag, forward_iterator_tag)
{
    if (__first2 == __last2)
        return make_pair(__first1, __first1);  // Everything matches an empty sequence
    while (true)
    {
        // Find first element in sequence 1 that matchs *__first2, with a mininum of loop checks
        while (true)
        {
            if (__first1 == __last1)  // return __last1 if no element matches *__first2
                return make_pair(__last1, __last1);
            if (__pred(*__first1, *__first2))
                break;
            ++__first1;
        }
        // *__first1 matches *__first2, now match elements after here
        _ForwardIterator1 __m1 = __first1;
        _ForwardIterator2 __m2 = __first2;
        while (true)
        {
            if (++__m2 == __last2)  // If pattern exhausted, __first1 is the answer (works for 1 element pattern)
                return make_pair(__first1, __m1);
            if (++__m1 == __last1)  // Otherwise if source exhaused, pattern not found
                return make_pair(__last1, __last1);
            if (!__pred(*__m1, *__m2))  // if there is a mismatch, restart with a new __first1
            {
                ++__first1;
                break;
            }  // else there is a match, check next elements
        }
    }
}

template <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>
_LIBCPP_CONSTEXPR_AFTER_CXX11
pair<_RandomAccessIterator1, _RandomAccessIterator1>
__search(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,
         _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,
           random_access_iterator_tag, random_access_iterator_tag)
{
    typedef typename iterator_traits<_RandomAccessIterator1>::difference_type _D1;
    typedef typename iterator_traits<_RandomAccessIterator2>::difference_type _D2;
    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern
    const _D2 __len2 = __last2 - __first2;
    if (__len2 == 0)
        return make_pair(__first1, __first1);
    const _D1 __len1 = __last1 - __first1;
    if (__len1 < __len2)
        return make_pair(__last1, __last1);
    const _RandomAccessIterator1 __s = __last1 - (__len2 - 1);  // Start of pattern match can't go beyond here

    while (true)
    {
        while (true)
        {
            if (__first1 == __s)
                return make_pair(__last1, __last1);
            if (__pred(*__first1, *__first2))
                break;
            ++__first1;
        }

        _RandomAccessIterator1 __m1 = __first1;
        _RandomAccessIterator2 __m2 = __first2;
         while (true)
         {
             if (++__m2 == __last2)
                 return make_pair(__first1, __first1 + __len2);
             ++__m1;          // no need to check range on __m1 because __s guarantees we have enough source
             if (!__pred(*__m1, *__m2))
             {
                 ++__first1;
                 break;
             }
         }
    }
}

#if _LIBCPP_STD_VER > 14

// default searcher
template<class _ForwardIterator, class _BinaryPredicate = equal_to<>>
class _LIBCPP_TYPE_VIS default_searcher {
public:
    _LIBCPP_INLINE_VISIBILITY
    default_searcher(_ForwardIterator __f, _ForwardIterator __l,
                       _BinaryPredicate __p = _BinaryPredicate())
        : __first_(__f), __last_(__l), __pred_(__p) {}

    template <typename _ForwardIterator2>
    _LIBCPP_INLINE_VISIBILITY
    pair<_ForwardIterator2, _ForwardIterator2>
    operator () (_ForwardIterator2 __f, _ForwardIterator2 __l) const
    {
        return _VSTD::__search(__f, __l, __first_, __last_, __pred_,
            typename _VSTD::iterator_traits<_ForwardIterator>::iterator_category(),
            typename _VSTD::iterator_traits<_ForwardIterator2>::iterator_category());
    }

private:
    _ForwardIterator __first_;
    _ForwardIterator __last_;
    _BinaryPredicate __pred_;
    };

#endif // _LIBCPP_STD_VER > 14

#if _LIBCPP_STD_VER > 17
template <class _Tp>
using unwrap_reference_t = typename unwrap_reference<_Tp>::type;

template <class _Tp>
using unwrap_ref_decay_t = typename unwrap_ref_decay<_Tp>::type;
#endif // > C++17

template <class _Container, class _Predicate>
inline void __libcpp_erase_if_container( _Container& __c, _Predicate __pred)
{
	for (typename _Container::iterator __iter = __c.begin(), __last = __c.end(); __iter != __last;)
	{
		if (__pred(*__iter))
			__iter = __c.erase(__iter);
		else
			++__iter;
	}
}

_LIBCPP_END_NAMESPACE_STD

#endif  // _LIBCPP_FUNCTIONAL
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               …      ”               0.0.0 şÿÿÿ      ÿÿfš†!ë5˜9İ4QÁóB   í          7  €ÿÿÿÿ     €            ¦ €² €                      E €                   Ş  €#          €           . €,          €           5   a €                   Ş  €#          €           . €,          €           † €r €                   Ş  €#      	    €           . €,      
    €           H €« €ÿÿÿÿ   €          1  €1  €ÿÿÿÿ   @           Ş  € €                  Q  €j  €                  ñ  €J   ÿÿÿÿ   À           1  €1  €ÿÿÿÿ   €            Ş  € €                    €j  €ÿÿÿÿ   €            \   ›  €ÿÿÿÿ   €            H €r   ÿÿÿÿ   €           1  €1  €ÿÿÿÿ   @            Ş  € €                   Q  €j  €                   H €w   ÿÿÿÿ   €           1  €1  €ÿÿÿÿ   @            Ş  € €                   Q  €j  €                   H €€   ÿÿÿÿ   €           1  €1  €ÿÿÿÿ   @            Ş  € €                   Q  €j  €                   y €
 €                    Ş  €#      !    €           . €,      "    €            €…   ÿÿÿÿ#   @          1  €1  €ÿÿÿÿ$               Ş  € €   %               . €j  €   &               Õ €“   ÿÿÿÿ'    €           1  €1  €ÿÿÿÿ(    À            Ş  € €   )                  €j  €ÿÿÿÿ*    €            H €›  €ÿÿÿÿ+    €           1  €1  €ÿÿÿÿ,   @            Ş  € €   -                Q  €j  €   .                y €
 €   /                 Ş  €#      0    €           . €,      1    €             €§      2    @            ¾ €¶      3    @            Ş  €#      4    €           . €,      5    €           H €»   ÿÿÿÿ6   €           1  €1  €ÿÿÿÿ7   @            Ş  € €   8                Q  €j  €   9                H €Æ   ÿÿÿÿ:   €           1  €1  €ÿÿÿÿ;   @            Ş  € €   <                Q  €j  €   =                H €Ø   ÿÿÿÿ>   €           1  €1  €ÿÿÿÿ?   @            Ş  € €   @                Q  €j  €   A              MonoImporter PPtr<EditorExtension> m_FileID m_PathID PPtr<PrefabInstance> m_ExternalObjects SourceAssetIdentifier type assembly name m_UsedFileIDs m_DefaultReferences executionOrder icon m_UserData m_AssetBundleName m_AssetBundleVariant     s    ÿÿ£Gñ×ÜZ56 :!@iÁJ*          €7  €ÿÿÿÿ     €            ¦ €² €                       E €                   Ş  €          €           . €          €           (   a €                   Ş  €          €           . €          €           † €r €                   Ş  €      	    €           . €      
    €           H €« €ÿÿÿÿ   €          1  €1  €ÿÿÿÿ   @           Ş  € €                  Q  €j  €                  H €ê €ÿÿÿÿ   €           1  €1  €ÿÿÿÿ   @            Ş  € €                   Q  €j  €                   ñ  €=   ÿÿÿÿ   €           1  €1  €ÿÿÿÿ   €            Ş  € €                    €j  €ÿÿÿÿ   €            H €›  €ÿÿÿÿ   €           1  €1  €ÿÿÿÿ   @            Ş  € €                   Q  €j  €                   y €
 €                   Ş  €          €           . €          €           y €Q                       Ş  €          €           . €           €           Ş  €X      !                H €i   ÿÿÿÿ"   €           1  €1  €ÿÿÿÿ#   @            Ş  € €   $                Q  €j  €   %                H €u   ÿÿÿÿ&   €           1  €1  €ÿÿÿÿ'   @            Ş  € €   (                Q  €j  €   )              PPtr<EditorExtension> m_FileID m_PathID PPtr<PrefabInstance> m_DefaultReferences m_Icon m_ExecutionOrder m_ClassName m_Namespace                        \       ày¯     `       4                                                                                                                                                ày¯                                                                                    PlaceholderTestsÇ   using NUnit.Framework;

internal class U2DExtrasPlaceholder 
{
    [Test]
    public void PlaceHolderTest()
    {
        Assert.Pass("2D Extras tests are in a separate package.");
    }
}
                        PlaceholderTests                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ‹      í}ıoÇ±àï÷WLx	dÚÎ×K˜L ’²d%¢Äˆ´'Ãİ&wÂÙ™õÌ¬(zß¢B@´ì x’Jyr$A§wôˆe;¡ş"ÉuUwõt÷ôÌÎRR·§?ª»««ªë«g†9óò"‹:ÅÌ_+zQ>»ÅÖags±7L6ßïçûùû;ÅûüÓû8bI´¯úïÿşëßœóŞk¿şõğİïï7şèG?øÑ÷~ôÃ¹×˜_œ~:*~½²İ_KãÙ"]áÀ$«áÆo‚™¥´;ŒÙÌ;i’^ŒºQÆ:E”&s3q‘Íø!şX“‹YwnæøèÑñÑÎñóëÇGO¾‚¿á¿gÇGn?ÿ=ü_÷ñë~ùõù4yşÑñÑÓŸ>ÈÎïjóoİ;>Ú¥~ïİ8>:<>º‰…GÇGÿyüœÿñº0ú
»İ¥audW ùó½ã£‡ô“wx“W‹£¤Ï—&Á?ğî ŒĞKõÃ‚uWŠ¨³É2¨tp|tGÎQÀàğ‰|‚?¤Å¡¡€îsìkot€PÂ@÷DY7KPş.ÉVnŠ
Y:Lp•`×!tF­4Ìº²o¾â†I@gû|MÃ>ËB5.4>Ä6âÃ[I¸&·Ğø“¹ó¼%|ƒŸóYQ»3Q^Ó°®àŠS`ÛYˆK+zy&À‹ÓœA¡ì—¤qJ;ğ5üìbV0¹Á¸	7q`›oãrpùê'ëQÖ— ü×ğ.à>~,¢dˆrÈ¿t#+ßxÜW^˜i_NşKÜŒ}Äœë´¼İt+‰Ó°+{|8
èÀÑämŞí²Ú»Q—¥u±P,ì×X~­“šù%ĞdÆgëëüèæ²‡í3üã3¬»ƒSâ‹Ã®Exñ?¾'ëßæ¼D©CD×õT”Ï$rËÖëQ\°,—_¾Â¼ÇDŸ£\İÇ¸+÷¡dfÅy*ß§U¿AH`ÕT+tˆ›vÒÚD	¶§Ø_é˜%´
Op¸Ÿ¾r+å¡Ò»Ÿñû‚–ì"	¹'ı1şñ®3ÿ|)‰·ë«àÈwáø_Ğ]…™qš‹[)F}X3©~”ei¶ÂÖ9‰7i	bßG²oêcüô6Ş£–jkº†L3vi ô7ø¶zJëøW0.+¨äCŞƒI‡áíıx‡’O8şá†¨"áã_n)âÊ«°kˆŸÙŞEtÉØÕˆmIXã”Ä™8œ¦ƒ\.ôáñsŞßŸq{ÓISäUÖ~Ë’Dª/°úhÆÄá¶B- nÊX˜³+!+ì¾d†ò4`;I$•„CAô>ÇÉaı[ˆ*{8ª¨üùÉ —©v¤ ‰]øWµÀÍ°§›åÜq–ÕoÂ¢u±¯»x>ÆÿŠûéU&h3 Š¢+²mY.øÅï$âÂ<ğëR­òfw0ÌA«%gÙ79gÎyF§5v5ø÷2gl‰c­$§Ï‘3Äb‹vkâ%‚×çÌªeéfI}KøÙı‹èh¸Ödõ GæË\pyiqÎU€0±ªı‚ooĞŒw‰z=ZÈÍuşÙPo¥r®$'v¿Ô×°M·c&Nî<<ŸÔµèñMIX‹§ÄyŸAa-	£¸±²È#—~ûe!ŞQ»–mÏo„Qb`ò!®¢:À‚šóÊ|{Ò’ÏYø.¦a"‰.[Ùto8 3ãäs¥$LU—‰8ë;iƒh¨É´ÎZÈ––9iÃ:Š„=ß!™à¡Nñ\¬{˜¸²Ş
Û 9ü€Èİ¾&î×t¿JÛnÌã†À
¬ÿˆ„ñ†®`-‹"57ÙmëöœßÒ¬»ÒÉKÊ^î	é·ÿ/$Ùï3Û“CË¥¨ÓĞljb;ò»Ùy›äyÁ›’”wo"Æ‰ã#ä¬O±;uKS"˜½PÊmZ±âçSD!å‹uàd$cå¬.ˆ{$ˆü	K8Öiì'Áh-–7¨ÛxœğçB<”â#r,¢YBn?$A
k×VÏeŠ‰ßÅEëÏ¼NmôŠÆñPĞÏÁÈşnĞù~jÖ¹Œ÷§ç;Äœégœúpn8<O¸¼f3.7ï¡¬\×Wµª=ÿJ…e)QßÂuy@ŒÕ¬3Ì¸àµÒ¾Y­eÍ»ò}5Lä÷»ÎY­²0v,íçy¹÷›Û¶Ãìƒa	1Kn.Mš.òp`Äåõ€îõFï±8Vòs–YsÙHã®ªÄ¥pÃ‰Pn;—N !í‰¨x¥	ÑùQ«R¬#*M¯ÔIPZÜ¨Ö­ÃæJÅKY˜ˆ:ê8ÉQ©f9¬jªúa–¦‰ij³n“ òœ‹öëëÕeDşkÜÊ4®²ºUxˆ*—uO°× û˜Uväcìâ¶øZ×·QÉµrF…ÌÔ+æ\­ğÂv@øô„ê»7ÄQ»#/s´Å;‡¶9\Ì2ö¤Ä¶Çœ×úXÏø[aÖ¯ì:ğ9B%Î5åmnËªÆylíJsf•£0I¸¤Şa8Şäs#Ğ˜Š‹”qwôF#¸èÇŞn	‚z©@Ã¯BúOD¶}äÉ	á–ÔşÕu¿Ÿ#‚Ê‹ˆ¸*kŒş¦©Oì2©YkÑ%^Õk—Ë—Q'„¨Õ‘¼a
‰:Ç“½ÀôÌÚÚÕ¥ˆßÂÌ]*™jáX7*.¹oôú<+]é!ÃLvq1ëÆZ£ÁÛi}˜&ât‹u} ‰Jw¤¸FŠišä¾èúbšõOÒ­¦*Ó>bÆ¼ø»fíQM	”NTÛ'±
ôg$#šÜé#Mz$^‰“îœXívUÿ‰ô~­7o±«w	õ]ùcõ©Í—5½ğ˜7Ä5·Í€ï¦_¿p½ÀÃ¤2Æ¿UPg»¼<&I^ÉöÈ@EOÏQıd š¸€Ü!¥Vyï{ó7¾¥‘Õ8xG ó1¶ÿFDÊÒ‚“œÅÅ+íVBëÉ˜}Ù%îÄSM ½‰MÄ½òÿÒ*G~‰«óŞ<pŞá,¿ıá¹¯m~A¶Ò·dÇmqª®['~}‹sÇ0‹Âá‹9_}Ö`n´
q©Ÿ:{ty}h*¼ş£4o%WÃ|Š–w…Æ‡47©#~º†~£¹MZÈAšGÂ.ÚØğÑB¥Š%ÄœÉÍè/÷¨mC÷ñ½Xô‘.F`sá¶2ƒP[:rM(Ğ8öÇtõ°jÌÙâ²v]à€R!ª8›]¥d\Ä–ZMÎÉ¥tjI5Ò´¡1úÊõÆâ!í»Cg	À–çS£ğz=	‡š©´©tÓ·Ä ×zÊĞà†ŞNBXëè›sï5ÊÙ²¾9?CñMµµÙrSÕ(é²kœ+²<Ûş‡Ã¼¯ÌòN? ÍoXş•árS,°zç]’Öàİë#ÒQØw´›:€l2³Ö€ÚÔ¤
p­NuÈ•EÕµÌQ|¾Nö>q­³èb/u{Ğ²'İ¶TÈ³Må/÷¸V]Åm¯¼ZEÚ¨¾ÑÃCtx;—fx÷Z÷6û=vÁlW
N‰A1ú'ÈxêXù—Ìº™#×rÛ"Mã"ä¯œßz¯!ø÷¥üuëzØÁcAP<°&æƒ°ÃNÿÓ3gyOx	ÌÙ\,BìãÂ<¡¾i‘Nå§N¿8Cç£Ú#}¬uSglÚ©Æ>¹(0a¾7ÈZB—@˜Bš˜<æ_4C±sØ-¶A&©½7N’F^¥b¹S'ñå{€`€ZQ¥~¦’\Úw£	2œ‡Á¨êğ¨¡é×R™WCâıõ4÷QÁ†PîÓaÖ|÷*–ıª3i#Íş‘ÖßùçÜÕ÷	Öû›ÈÇ~ŒÚ¹òé.¥5ş¢c?F‚¬ö¢|QÒè'_[©À4ê.9é _J»Bõ¨Ø¶ºVÙ7È {ˆz%¹Å†	ßpæò\&h:á/ş\³ô–“ù]bv‘µRÕaÅ¥é~š½ñøÛ£Q7ÜF-ıu¬÷Dèåzé0gy½((wÛ_ö_¤o¯ìÛÓO_)üÏø,a£A6Ã¿ç4´àÁÏÈ,ºCåé6=Õ&úºp=àˆËšV±Z«fIø%fØ‡ùÀ\añzÄª±²é¤ş>n¹@‹#+äo>×õ°ütƒQ§¦¼|eØé°<_Æ%D­I”Ü…ıêv«xdy¿‹Ó Ü6XWyÆV©ŸrsQŠ VÜh¥ïy¤ê×&w^MÎfrw+À
$Üª‡¨ä—D>¾Ó¯Ô«ìIÕQ…œôUG°ˆ÷ˆ¹ º´Ã|AÔÏ:şé*º6Ie³%½åÍûPmxéæ™¥Æº«éet·\)ØÀEÅ&û”»€®mx´Ş¥œ…-U¾e ŠçÂ;( µàg•ß";\Œ¯	qR÷‘„ñÛU²±È…ÍLÍÆtÉ–Nîò \=Á}Sy‘g-§]ä47KãI
cÇå:‹ú¥3Ó}2?t{ı8AŠğBµüO‰œbÊ|’=–Il×Ô™ñ!â}İÂû^BÖWzß,^_šíYYÇ÷F§:é0)Nâ)­7>í5øÆJ³«ôî²ÎuUp2AšOº+üRŸt[WÖ6ÁÌE!'½S‚æX.ÿ~ESh¸Ü—¿ªc¿ÑWB?s6ÍŞAù’¡t‘—j¬=¡TZÍílí–˜§èKr"ªÊa£Œ45W¸øş†.ær)wimÚØa,[svÒa«i˜‚
Ø&ÿûçt€ãö{¢LšÍŞ%¹zšdSÕaIH¼sçÏ
w€ÖØïãI‡½P]8ÜiÍªB­Î–]ã€‹b&1ò€_”­
•’1¾Î©îÑdküÅ'ŒáYòV‘‹‹B©ˆq6ÉKP0[m7yô±?F}–W£"&ZªÇïá`5]ìI+A„åå "ö˜BšœÙÆES{ZÖ(c#‘şnÉÕŒM?&oÉ³‡‚0ö—ø]"øøMŒÄºößÓô¾·-¡77¶2j.ñõ<_°~cÏqé°…bâ¹"w¸“°o`|H‹0¾¯°cÅ$òz8[l{Ò!M¥0Pª¨•0PÕ=k5—£Îæ‚ŒŸ¬oºËcÏé”t><m1ŸEÕL÷ù¼8İë°¤ {àır+JÍ—¸ÓøÄC’XÖú¶ı¡Š¡#ó3µ­nÒ û¤š]$/5””KŞbà"Eb<Â‚c¼’Ô…®T$S%Ú—, i¹!—k{= õaéBëoÒrX5®íZ}lÇu³÷!~ˆ2%QŸGÓ²iŠ:‘”dÉvŠE‰¢hEÊ®ayïnx\ko÷¼»'‰iÓÈ‘£ºMà8‘ƒº@`¤uêNãªJ*;µêÆiÒØHÕnZ ÈœIEœÂAä °úæÍŞîŞÇÊ÷G£@VÚßÍ{ï73ofŞ|ìrßû8D  Š÷µk /‚¼öÂû_gğ^±ùoWÀWš¯t¿È&¯tÏ.jv²h™yK-$³ªa˜N2Ã“VÉHjFrìH:Y0s<ÕÖÖr“[Æô>€I½r¾\î› t·²&€~âR7u!Yfì•iEúàÿÂç¥^\Øûq€vúïÿz?t]=‰‚…T6r9ş<Š¼=ô‰w¡M±	å9åğÓşÎn•\j«RSÄ)Ë¶²àúVö1UÉÛ‹ÿS×Í¬ô•F”5TÃ©vsàü=@Ybğën€Oö°FÚXçZ5ÀÈÌŸ åw±¢-[!Şw3(‘©Ïç(’Ã*8¬.G©à(u9‘
N¤.'ZÁ‰Vr"’«àÄêrâœx]Î²
Î²2G×¥zwb„#CYÉzwa²¯lºöÛ|ûî =æÚ÷øöÛëÙïğíw
ûJ/º×è
Œ¤0w¤…ß'‡R©]»‡vË€áv_+@Ïï\Æß«ØÎ´ciFŞŒ¯tÈ¹Ô3~tb¿ò«(èfÆlgËüÑ?cÍBøÛ«¿A5®”ıDs±ÎŸËØşS¯îÊÓs *=Ã§”#Ñh9«´À{ÊêxôÅD:éXô,vÀ«‘³Ê
¸Óq‹ü[,9ÂÿR¾Û¿ˆ‰r:PÓWâ‚óºòZqÈ_½ÓÌÚáh‹‘Ä°Å[°–2(ıu¼1˜	|Œğ»ìâKQ?%\û=˜NŠRÏ5íˆGÍ¢+í=‰’ãJ_?-ÿ¤+ıCüY”t¥uÑ§±×.¸Ò–è³(]v¥bìiì¡ï¸ÒGcÏ¢ô¦+}m1¸êJ‰¶D»¥ô»ˆ}°Á•ş›]B©×•^‹^„e°×•ş#z	¥IWºŠ¶&È¹RsìJEW:Œõ5Ã9W:†õÉş„ösM§ã)B¥t6~) -¡/­ô8úÒ
»¥|7òFé3®ôvä]¹Ö3Ê®A›'õ°ó¥¿À2WxÒ+X¦/- /+=ÉD_|éå¢·aœkzI¹„Ò·v-ÚÆğ®ô‘hJ¯»Ò§ÑÖ?v¥gĞÖá•òlä"¬ò¤#—Ò£h»Á“D›/ıÛĞéIqôÅ—ÖÃ5XíIs8*¾t ”æ±}Ñx/[ãIÛãıéO”l'ıqü.¶Ş–-Z{9ÖË6º¶‡›¾cém”6yRb›=é JIOZ€ÖíIgQºÑ“>R'½Œ’X|,òÁ#.˜89«×İLAÍÖ¸‚šÇâ"ı%ÂóqÉo$İ—c+àVÂn};xİMé{¿Ì4²>Dš%Ânœ«à8ÉÎ®ŸßnøX›À/~‹ğG„m+¦ŞKú<¥¿@ø
áFW
\G8N˜#<KÖG)=D%\].ps«ÀÛ>HøqÂ/~›°rı„Ò]”·p„pğc„_"|ƒ0BøÕû2áŸéx…ğÂõ«¨4BğqÂ’õJÇnØO8Gx†ğ9Âï¾Gøâ£¼ƒ„-„?§Ú›Ûn  <H¨:„~‘ğÂw	“	ê[Bƒğ³„—	ß"ŒP/ı˜FöyÂTLà#MØ8Ah~ŠğoÈúW”¾JØyGİhIS9'	Ïş;q^ ô§)ï<âø*é¯ş+á¯W+ï$tˆ”ÒO¾@ø=Âw	Wg'á)Ôl…'¨œïS}qÿÒDŞö5Óè>Bø¼D²ş3¥ãÔ'IÂ;çÂó„?%f3•ÿÊ›&<HšO^ |ƒğ„«—	,s7¥O>Eø*áÿ&ˆ³•ğÔôÀ'Ø0ÎÍMØ×«à5P1İYJÌ³‡Qsü)â¼‚xüñA`¬íÄZa->ùÄaKçcğ<?ƒ&Ze"´ƒÅ^BüVükˆ·F	¼@øsöMÄïG¶ÅŞGú?ˆ‹ôd}'r®]·°û¿I›¬¯|8šAıs„—#Bó9Â²n‘ë^*ÿw0—ô‹áo„nqBŠ"Šçˆe˜#*x7cº	QÁ»Ó-„ËqÇV0%°÷]†ûòJL¯¤sU»8Bã½
Óˆ
Ş˜¾p5¬AM'"Ãb¦×vÁzqÒBTğŞˆéˆ
Ş›1½	QÁ»ÓIDïLßHxlAMá\[ÜŒ¨à}+¦{¼·bºQÁ{b?lGÜƒ¨O!FÏ@Õµ_©|°í©½T¥V×YG×_ÖÍñ¬cZ;à·›¹’Î?;kZº–<wkö¸e–ŒÏ‘h—ì"7lÍ4ÒEq|?>a<ˆùÑj_×*ò.˜Ö)ÕÊí·´¬ƒ”Ê¬¡FªUËñSê’]?k¸UäÍrÃáVej]eËö.ª”˜Ô
ZmÓjÍEÎs³‹·ME‡íáŒy’WéFğÁú”¯«¬tL³ÕÈòªÊ<µÛY>\,N›šáTd¨o)ß/ô~^Ÿ+kw8·†¼îÖê‹GÍYÚgä5ƒ§FM‹ËĞ¨PO/.ÙZÖ®c™ã‹ZVçõLéEÕâ¹	Ñû†ª×aÀœª—øìR‘Ã8wæ1sÓ¦-İ=µÈ¹>¦ŠY3ª#®Q5NrK[ĞÔŒÎGÍvğ93SBËÏ”òy¡÷uSª£äSj! óÜ›ÓlÙ³f5ÿ WsØUvÔÄúuUß×ÕÓ”²}ûLÉp´44e4Ûë[OŠ&S3–z«³*ÉÆea/˜8Sö </:¢<FKÖI^wÂÖ§pPÄ›.Ÿ2­‚ªSvC&m?>Ò©œ®Cz	Ã¨@y­bî.©¢3±¦zK@½™_wÂ×ç2¾EŞ´®ƒå“lWÉ…ãi· nvµ¢p|ÔÔuÔX²s=‰–•²`Á	¬3¾ŸcštSˆv¥è;YæÚÙ®’Sbåv»<5¦©yÃ´œ”e•w)ŸÜJsë¤–å¶;p´qäPœáX2	ªm£&8Ê#š‘£75EÓÆP7´|ÉâîØ§KZÜ¤¯^ÒU_¤è-ëe¥æ´’Ô¹É‡0^Àâ˜ırã9 9²ûEbïÂqZå¨€"¥l/p[Æä0¶¦Ñ—Ê=’æÙ’…Üö.>òÚyêğËoşÓ‘BÛjhzáÃ÷Íuí|ó#ñDs4ÉØŠ1Y.´â!Ä °!ƒv­ÁQ%¾\d•-™ƒq	<²TDâ‰6<ÚxqÑe¬#MBG"†`rNA¢YÈ‰æÈ2¶<’„åÂÏåÑ^ä! º–oÁ3‰l¼½½<A·Wpj‘*Ht‰»¨À.,L…)Â°Q6’a£hí„ $²x2Â–755'ÖhnOtÇ“LiO4áPÈŸ.ù³Q8Ö…)"±qƒ.wëHg-­è`dêtäæijbîïMâ5Ù¬²zŞR‹SbçÍò¢˜ù¸‰š§lF"{½ÈÜJàfİï¿ûÀz<†lxpƒÍAÛp§í.áeR&+HeK7+,FÎ2µÜÁ)‘d°¾’¡hû(D‡…ï»5L™Âi®©ºöa¯¬	’&ŒbÉ	õ~&Ì·¦ƒÛ›©æÊ„l¬ÈŠÃèŒ` è¡U—ršfÕMg±lìÁsvĞHi\~<³•9[ñl]ÃÆÁ]Ë .{¿#×1èrg'ÓeSu Pzgf8î¬¶W›˜Yáµ…±F-Õ^œáEÓrä‚K¬ÍøtdáÂAçğP{zzgÁb˜Ë5qø±ÑS€ãxÒ¥])løÇ'ÂæÅ¸¥åÂÂn–ŸÆØÀÂ
´±:<(ì&y^Í.…Fæáñ£a0ifEXWLêŞV±›Å¾Dë}XœLskA¬æxJ®™ê¨w'ÜĞXØĞL[æ‚Ø]Ëö½îÚİ]xUrZ1&Å$R2ËW[a‹%çÆ¨ZtJşÊT=²âôæpÜlO„u¿dà"XäamM;W×éÚîE·…ºêzo>T/`³Ü²T-t ]sÕ2w+>VWÇ›X§÷›†ÜïÃ™â·’YãbA-†M?.oÁ'ıJË>Ì‰³Ê–a}ãóÂÂÿhüaóïèÔ¾Ù°q‘‹cÉÒË„^=5„Y\Ì0Zeâ ƒşë¬}u–ôº‹n Gp…ßÆ ÷:\1(˜®»*öüü|Ø¬zæ¬Yìçöëó9<™aƒ~l&Ì276Nóx^.Û62X[1=NiNv1,eÌÓGü ­nÄtzgX#Ğä;T›oWx¾]á™âÎ)Ó:!
a5ƒDÕV]ÊÕ¶€Ô)÷9à+Éœò¶ÉZ÷¦ëï°r?¯üáîzfË¹UÛé’•]TmjGµML	\ qèîdĞîz[rLy+S#%ËÆg5:ŠÔ¾œ&Ãüí*5Æ‹º¹$¼ÅÛ)ï¹Ë¯>%¡y‹ê @ƒ-õmUıØ!j©³¸Õètüõ:³–´ßÂs€Û`kÜ}ÊõÆ[¼*ôÁœŞ2ÂH¹%í` Üv%7QB9ßÀŠ²‡u}Â,×*+$Éo´˜på‡¾m£âÄ_Üæ`^ñÚGº\m]Ğp‹øàÕl{â½ªÏZjVN±Œ›fŸ0gdãäÒ˜´àcÊá™`4ù04æîÈ^ yµÖØÜ^ñf/n%|š.æjrKR\FÍvT›Û-ßŸ şVĞÏà–úÛ˜8MÉˆ—¨µ;Z€Vg†ŒÓº*ƒµqWS€Ëğ†İó'°$­—a‹Ó@ƒ6i/eó©»Ít0ğËÓSê}ê¤IïH‚¶ƒÑÑÄLööOW]o©L‰nNïªì`¹nHË7	e¦<Ô§Ê©ÃÓ²•#xøÎóÔÀÀ`c´¡Æh;£ílŒ¶«1ÚmÑv7FÛÓíö†hƒÑ…ÁÆFa°±Qll…ÁÆFa°±Qll…¡ÆFa¨±Qjl†…¡sjmŒŸ”SµAæPÃÌ3÷sWpÕõàR3<¯Ùån\ô±Ü™§RìÌ#UïRÅ¶^ĞlñÚÁö”¾ÎûCG²ü—Åşäœ|Mq—øPÿõ'GKºx¸Ëà%¬RïON—2º–=Ä—fÍÜ¸+³{·º+»ë¶ÁÛwìä{nïd³J{ú„Vœ£¿ödÉËò·¦ô0;<-şÄ)>AüÚA¼û+ÿşüv÷—h›I¥«ß	‹òÂŸ2RÅ\·İC~9ªø¶¸ò8T­9‹ş˜®Æ§]ù7W.ÿ„"®k[ ¹·~Aÿ/.Fı»V~A\¡}:PG/.ñíğ± ü½ú	æ Ç÷Á¦&àL¡<¸Óâú»èÏŞ«÷µño»¿â›Ïê?ƒQÍs ‚…åh Ç2X “ì7Q®Y´ª¨µÑ®‚ƒ<%y]ˆ¾ÃDiÔ[h1 _§¤×‰3àıÛ	ÑĞO_>”ùcxÛ¥rŠõ$©ÏšÜ9¼-dûœHn€ûéKáƒC\}×±¿T( ŒqmKØ§Âká;Ç¼¢äE”²T‡±†”HJaJ¡½äû$jóTò(òŠXšğ>%8®ßäÇW¯¹~”ÛaüŸù³“úgë‘ö,–UİKÕ}´‡ò#ÃFfGEÇú“ï›ï7Wk¯üö{úÎÚ‘ß\Äõ¿                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              // -*- C++ -*-
//===---------------------------- chrono ----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_CHRONO
#define _LIBCPP_CHRONO

/*
    chrono synopsis

namespace std
{
namespace chrono
{

template <class ToDuration, class Rep, class Period>
constexpr
ToDuration
duration_cast(const duration<Rep, Period>& fd);

template <class Rep> struct treat_as_floating_point : is_floating_point<Rep> {};

template <class Rep> inline constexpr bool treat_as_floating_point_v
    = treat_as_floating_point<Rep>::value;                       // C++17

template <class Rep>
struct duration_values
{
public:
    static constexpr Rep zero(); // noexcept in C++20
    static constexpr Rep max();  // noexcept in C++20
    static constexpr Rep min();  // noexcept in C++20
};

// duration

template <class Rep, class Period = ratio<1>>
class duration
{
    static_assert(!__is_duration<Rep>::value, "A duration representation can not be a duration");
    static_assert(__is_ratio<Period>::value, "Second template parameter of duration must be a std::ratio");
    static_assert(Period::num > 0, "duration period must be positive");
public:
    typedef Rep rep;
    typedef typename _Period::type period;

    constexpr duration() = default;
    template <class Rep2>
        constexpr explicit duration(const Rep2& r,
            typename enable_if
            <
               is_convertible<Rep2, rep>::value &&
               (treat_as_floating_point<rep>::value ||
               !treat_as_floating_point<rep>::value && !treat_as_floating_point<Rep2>::value)
            >::type* = 0);

    // conversions
    template <class Rep2, class Period2>
        constexpr duration(const duration<Rep2, Period2>& d,
            typename enable_if
            <
                treat_as_floating_point<rep>::value ||
                ratio_divide<Period2, period>::type::den == 1
            >::type* = 0);

    // observer

    constexpr rep count() const;

    // arithmetic

    constexpr common_type<duration>::type  operator+() const;
    constexpr common_type<duration>::type  operator-() const;
    constexpr duration& operator++();    // constexpr in C++17
    constexpr duration  operator++(int); // constexpr in C++17
    constexpr duration& operator--();    // constexpr in C++17
    constexpr duration  operator--(int); // constexpr in C++17

    constexpr duration& operator+=(const duration& d);  // constexpr in C++17
    constexpr duration& operator-=(const duration& d);  // constexpr in C++17

    duration& operator*=(const rep& rhs);       // constexpr in C++17
    duration& operator/=(const rep& rhs);       // constexpr in C++17
    duration& operator%=(const rep& rhs);       // constexpr in C++17
    duration& operator%=(const duration& rhs);  // constexpr in C++17

    // special values

    static constexpr duration zero(); // noexcept in C++20
    static constexpr duration min();  // noexcept in C++20
    static constexpr duration max();  // noexcept in C++20
};

typedef duration<long long,         nano> nanoseconds;
typedef duration<long long,        micro> microseconds;
typedef duration<long long,        milli> milliseconds;
typedef duration<long long              > seconds;
typedef duration<     long, ratio<  60> > minutes;
typedef duration<     long, ratio<3600> > hours;

template <class Clock, class Duration = typename Clock::duration>
class time_point
{
public:
    typedef Clock                     clock;
    typedef Duration                  duration;
    typedef typename duration::rep    rep;
    typedef typename duration::period period;
private:
    duration d_;  // exposition only

public:
    time_point();  // has value "epoch" // constexpr in C++14
    explicit time_point(const duration& d);  // same as time_point() + d // constexpr in C++14

    // conversions
    template <class Duration2>
       time_point(const time_point<clock, Duration2>& t); // constexpr in C++14

    // observer

    duration time_since_epoch() const; // constexpr in C++14

    // arithmetic

    time_point& operator+=(const duration& d); // constexpr in C++17
    time_point& operator-=(const duration& d); // constexpr in C++17

    // special values

    static constexpr time_point min();  // noexcept in C++20
    static constexpr time_point max();  // noexcept in C++20
};

} // chrono

// common_type traits
template <class Rep1, class Period1, class Rep2, class Period2>
  struct common_type<chrono::duration<Rep1, Period1>, chrono::duration<Rep2, Period2>>;

template <class Clock, class Duration1, class Duration2>
  struct common_type<chrono::time_point<Clock, Duration1>, chrono::time_point<Clock, Duration2>>;

namespace chrono {


template<class T> struct is_clock;  // C++20
template<class T> inline constexpr bool is_clock_v = is_clock<T>::value;   // C++20


// duration arithmetic
template <class Rep1, class Period1, class 