 else {
            scriptLoader = new OnlyOnceScriptLoader(new BrowserScriptLoader());
        }
        moduleManager = new ModuleManager(scriptLoader);
        scriptLoader.setModuleManager(moduleManager);
    }
    function initConsole() {
        // Define used console.* functions, in order to not fail in environments where they are not available
        if (!isNode) {
            if (!global.console) {
                global.console = {};
            }
            if (!global.console.log) {
                global.console.log = function () {
                };
            }
            if (!global.console.warn) {
                global.console.warn = global.console.log;
            }
            if (!global.console.error) {
                global.console.error = global.console.log;
            }
        }
    }
    function initMainScript() {
        if (!isWebWorker && !isNode) {
            window.onload = function () {
                var i, len, main, scripts = document.getElementsByTagName('script');
                for (i = 0, len = scripts.length; i < len; i++) {
                    main = scripts[i].getAttribute('data-main');
                    if (main) {
                        break;
                    }
                }
                // Load the main script
                if (main) {
                    moduleManager.defineModule(Utilities.generateAnonymousModule(), [main], null, null, new ModuleIdResolver(new Configuration(), ''));
                }
            };
        }
    }
    function init() {
        initVars();
        initConsole();
        initMainScript();
        if (isNode) {
            global.nodeRequire = global.require;
        }
        if (isNode && !isAtomShell) {
            module.exports = RequireFunc;
        }
        else {
            // The global variable require can configure the loader
            if (typeof global.require !== 'undefined' && typeof global.require !== 'function') {
                RequireFunc.config(global.require);
            }
            if (!isAtomShell) {
                global.define = DefineFunc;
            }
            else {
                define = function () {
                    DefineFunc.apply(null, arguments);
                };
            }
            global.require = RequireFunc;
            global.require.__$__nodeRequire = global.nodeRequire;
        }
    }
    if (typeof global.define !== 'function' || !global.define.amd) {
        init();
    }
})(AMDLoader || (AMDLoader = {}));
/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
(function(global) {

'use strict';

/* To test Daytona Resource support 
global.Plugin = {};
global.Plugin.Resources = {};
global.Plugin.Resources.getString = function (key, arg1, args2, args3) {
	return key;
};
*/

var Resources = global.Plugin && global.Plugin.Resources ? global.Plugin.Resources : undefined;

var DEFAULT_TAG = 'i-default';

function _format(message, args) {
    var result= message.replace(/\{(\d+)\}/g, function(match, rest) {
        var index= rest[0];
        return typeof args[index] !== 'undefined' ? args[index] : match;
    });
    if (self && self.document && self.document.URL.match(/[^\?]*\?[^\#]*pseudo=true/)) {
        // FF3B and FF3D is the Unicode zenkaku representation for [ and ]
        result= '\uFF3B' + result.replace(/[aouei]/g, '$&$&') + '\uFF3D';
    }
    return result;      
}

function findLanguageForModule(config, name) {
    var result = config[name];
    if (result)
        return result;
    result = config['*'];
    if (result)
        return result;
    return null; 
}


function localize(data, message) {
    var args = [];
    for (var _i = 0; _i < (arguments.length - 2); _i++) {
        args[_i] = arguments[_i+2];
    }
    return _format(message, args);
}

define('vs/nls', {
    load: function (name, req, load, config) {
		config = config || {};
        if (!name || name.length === 0 || config.isBuild) {
            load({
                localize: localize
            });
        } else  {
			var suffix;
			if (Resources) {
				suffix = '.nls.keys';
				req([name + suffix], function(keyMap) {
					load({
	                    localize: function(moduleKey, index) {
	                        if (!keyMap[moduleKey])
	                            return 'NLS error: unkown key ' + moduleKey;
	                        var mk = keyMap[moduleKey].keys;
	                        if (index >= mk.length)
	                            return 'NLS error unknow index ' + index;
							var subKey = mk[index];
	                        var args = [];
	                        args[0] = moduleKey + '_' + subKey;
	                        for (var _i = 0; _i < (arguments.length - 2); _i++) {
	                            args[_i + 1] = arguments[_i + 2];
	                        }
							return Resources.getString.apply(Resources, args);
						}
					});
				});
			} else {
	            var pluginConfig = config['vs/nls'] || {};
	            var language = pluginConfig.availableLanguages ? findLanguageForModule(pluginConfig.availableLanguages, name) : null;
	            suffix = '.nls';
	            if (language !== null && language !== DEFAULT_TAG) {
	                suffix = suffix + '.' + language;
	            }
	            
	            req([name + suffix], function(messages) {
	                load({
	                    localize: function(moduleKey, index) {
	                        var args = [];
	                        for (var _i = 0; _i < (arguments.length - 2); _i++) {
	                            args[_i] = arguments[_i+2];
	                        }
	                        if (!messages[moduleKey])
	                            return 'NLS error: unkown key ' + moduleKey;
	                        var mm = messages[moduleKey];
	                        if (index >= mm.length)
	                            return 'NLS error unknow index ' + index;
	                        return _format(mm[index], args);
	                    }
	                });
	            });
			}
        }
    },
    localize: localize
});

}(this));/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
/// <reference path="declares.ts" />
/// <reference path="loader.ts" />
'use strict';
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var _cssPluginGlobal = this;
var CSSLoaderPlugin;
(function (CSSLoaderPlugin) {
    var global = _cssPluginGlobal;
    /**
     * Known issue:
     * - In IE there is no way to know if the CSS file loaded successfully or not.
     */
    var BrowserCSSLoader = (function () {
        function BrowserCSSLoader() {
            this._pendingLoads = 0;
        }
        BrowserCSSLoader.prototype.attachListeners = function (name, linkNode, callback, errorback) {
            var unbind = function () {
                linkNode.removeEventListener('load', loadEventListener);
                linkNode.removeEventListener('error', errorEventListener);
            };
            var loadEventListener = function (e) {
                unbind();
                callback();
            };
            var errorEventListener = function (e) {
                unbind();
                errorback(e);
            };
            linkNode.addEventListener('load', loadEventListener);
            linkNode.addEventListener('error', errorEventListener);
        };
        BrowserCSSLoader.prototype._onLoad = function (name, callback) {
            this._pendingLoads--;
            callback();
        };
        BrowserCSSLoader.prototype._onLoadError = function (name, errorback, err) {
            this._pendingLoads--;
            errorback(err);
        };
        BrowserCSSLoader.prototype._insertLinkNode = function (linkNode) {
            this._pendingLoads++;
            var head = document.head || document.getElementsByTagName('head')[0];
            var other = head.getElementsByTagName('link') || document.head.getElementsByTagName('script');
            if (other.length > 0) {
                head.insertBefore(linkNode, other[other.length - 1]);
            }
            else {
                head.appendChild(linkNode);
            }
        };
        BrowserCSSLoader.prototype.createLinkTag = function (name, cssUrl, externalCallback, externalErrorback) {
            var _this = this;
            var linkNode = document.createElement('link');
            linkNode.setAttribute('rel', 'stylesheet');
            linkNode.setAttribute('type', 'text/css');
            linkNode.setAttribute('data-name', name);
            var callback = function () { return _this._onLoad(name, externalCallback); };
            var errorback = function (err) { return _this._onLoadError(name, externalErrorback, err); };
            this.attachListeners(name, linkNode, callback, errorback);
            linkNode.setAttribute('href', cssUrl);
            return linkNode;
        };
        BrowserCSSLoader.prototype._linkTagExists = function (name, cssUrl) {
            var i, len, nameAttr, hrefAttr, links = document.getElementsByTagName('link');
            for (i = 0, len = links.length; i < len; i++) {
                nameAttr = links[i].getAttribute('data-name');
                hrefAttr = links[i].getAttribute('href');
                if (nameAttr === name || hrefAttr === cssUrl) {
                    return true;
                }
            }
            return false;
        };
        BrowserCSSLoader.prototype.load = function (name, cssUrl, externalCallback, externalErrorback) {
            if (this._linkTagExists(name, cssUrl)) {
                externalCallback();
                return;
            }
            var linkNode = this.createLinkTag(name, cssUrl, externalCallback, externalErrorback);
            this._insertLinkNode(linkNode);
        };
        return BrowserCSSLoader;
    })();
    /**
     * Prior to IE10, IE could not go above 31 stylesheets in a page
     * http://blogs.msdn.com/b/ieinternals/archive/2011/05/14/internet-explorer-stylesheet-rule-selector-import-sheet-limit-maximum.aspx
     *
     * The general strategy here is to not write more than 31 link nodes to the page at the same time
     * When stylesheets get loaded, they will get merged one into another to free up
     * some positions for new link nodes.
     */
    var IE9CSSLoader = (function (_super) {
        __extends(IE9CSSLoader, _super);
        function IE9CSSLoader() {
            _super.call(this);
            this._blockedLoads = [];
            this._mergeStyleSheetsTimeout = -1;
        }
        IE9CSSLoader.prototype.load = function (name, cssUrl, externalCallback, externalErrorback) {
            if (this._linkTagExists(name, cssUrl)) {
                externalCallback();
                return;
            }
            var linkNode = this.createLinkTag(name, cssUrl, externalCallback, externalErrorback);
            if (this._styleSheetCount() < 31) {
                this._insertLinkNode(linkNode);
            }
            else {
                this._blockedLoads.push(linkNode);
                this._handleBlocked();
            }
        };
        IE9CSSLoader.prototype._styleSheetCount = function () {
            var linkCount = document.getElementsByTagName('link').length;
            var styleCount = document.getElementsByTagName('style').length;
            return linkCount + styleCount;
        };
        IE9CSSLoader.prototype._onLoad = function (name, callback) {
            _super.prototype._onLoad.call(this, name, callback);
            this._handleBlocked();
        };
        IE9CSSLoader.prototype._onLoadError = function (name, errorback, err) {
            _super.prototype._onLoadError.call(this, name, errorback, err);
            this._handleBlocked();
        };
        IE9CSSLoader.prototype._handleBlocked = function () {
            var _this = this;
            var blockedLoadsCount = this._blockedLoads.length;
            if (blockedLoadsCount > 0 && this._mergeStyleSheetsTimeout === -1) {
                this._mergeStyleSheetsTimeout = window.setTimeout(function () { return _this._mergeStyleSheets(); }, 0);
            }
        };
        IE9CSSLoader.prototype._mergeStyleSheet = function (dstPath, dst, srcPath, src) {
            for (var i = src.rules.length - 1; i >= 0; i--) {
                dst.insertRule(Utilities.rewriteUrls(srcPath, dstPath, src.rules[i].cssText), 0);
            }
        };
        IE9CSSLoader.prototype._mergeStyleSheets = function () {
            this._mergeStyleSheetsTimeout = -1;
            var blockedLoadsCount = this._blockedLoads.length;
            var i, linkDomNodes = document.getElementsByTagName('link');
            var linkDomNodesCount = linkDomNodes.length;
            var mergeCandidates = [];
            for (i = 0; i < linkDomNodesCount; i++) {
                if (linkDomNodes[i].readyState === 'loaded' || linkDomNodes[i].readyState === 'complete') {
                    mergeCandidates.push({
                        linkNode: linkDomNodes[i],
                        rulesLength: linkDomNodes[i].styleSheet.rules.length
                    });
                }
            }
            var mergeCandidatesCount = mergeCandidates.length;
            // Just a little legend here :)
            // - linkDomNodesCount: total number of link nodes in the DOM (this should be kept <= 31)
            // - mergeCandidatesCount: loaded (finished) link nodes in the DOM (only these can be merged)
            // - blockedLoadsCount: remaining number of load requests that did not fit in before (because of the <= 31 constraint)
            // Now comes the heuristic part, we don't want to do too much work with the merging of styles,
            // but we do need to merge stylesheets to free up loading slots.
            var mergeCount = Math.min(Math.floor(mergeCandidatesCount / 2), blockedLoadsCount);
            // Sort the merge candidates descending (least rules last)
            mergeCandidates.sort(function (a, b) {
                return b.rulesLength - a.rulesLength;
            });
            var srcIndex, dstIndex;
            for (i = 0; i < mergeCount; i++) {
                srcIndex = mergeCandidates.length - 1 - i;
                dstIndex = i % (mergeCandidates.length - mergeCount);
                // Merge rules of src into dst
                this._mergeStyleSheet(mergeCandidates[dstIndex].linkNode.href, mergeCandidates[dstIndex].linkNode.styleSheet, mergeCandidates[srcIndex].linkNode.href, mergeCandidates[srcIndex].linkNode.styleSheet);
                // Remove dom node of src
                mergeCandidates[srcIndex].linkNode.parentNode.removeChild(mergeCandidates[srcIndex].linkNode);
                linkDomNodesCount--;
            }
            var styleSheetCount = this._styleSheetCount();
            while (styleSheetCount < 31 && this._blockedLoads.length > 0) {
                this._insertLinkNode(this._blockedLoads.shift());
                styleSheetCount++;
            }
        };
        return IE9CSSLoader;
    })(BrowserCSSLoader);
    var IE8CSSLoader = (function (_super) {
        __extends(IE8CSSLoader, _super);
        function IE8CSSLoader() {
            _super.call(this);
        }
        IE8CSSLoader.prototype.attachListeners = function (name, linkNode, callback, errorback) {
            linkNode.onload = function () {
                linkNode.onload = null;
                callback();
            };
        };
        return IE8CSSLoader;
    })(IE9CSSLoader);
    var NodeCSSLoader = (function () {
        function NodeCSSLoader() {
            this.fs = require.nodeRequire('fs');
        }
        NodeCSSLoader.prototype.load = function (name, cssUrl, externalCallback, externalErrorback) {
            var contents = this.fs.readFileSync(cssUrl, 'utf8');
            // Remove BOM
            if (contents.charCodeAt(0) === NodeCSSLoader.BOM_CHAR_CODE) {
                contents = contents.substring(1);
            }
            externalCallback(contents);
        };
        NodeCSSLoader.BOM_CHAR_CODE = 65279;
        return NodeCSSLoader;
    })();
    // ------------------------------ Finally, the plugin
    var CSSPlugin = (function () {
        function CSSPlugin(cssLoader) {
            this.cssLoader = cssLoader;
        }
        CSSPlugin.prototype.load = function (name, req, load, config) {
            config = config || {};
            var cssUrl = req.toUrl(name + '.css');
            this.cssLoader.load(name, cssUrl, function (contents) {
                // Contents has the CSS file contents if we are in a build
                if (config.isBuild) {
                    CSSPlugin.BUILD_MAP[name] = contents;
                }
                load({});
            }, function (err) {
                if (typeof load.error === 'function') {
                    load.error('Could not find ' + cssUrl + ' or it was empty');
                }
            });
        };
        CSSPlugin.prototype.write = function (pluginName, moduleName, write) {
            // getEntryPoint is a Monaco extension to r.js
            var entryPoint = write.getEntryPoint();
            // r.js destroys the context of this plugin between calling 'write' and 'writeFile'
            // so the only option at this point is to leak the data to a global
            global.entryPoints = global.entryPoints || {};
            global.entryPoints[entryPoint] = global.entryPoints[entryPoint] || [];
            global.entryPoints[entryPoint].push({
                moduleName: moduleName,
                contents: CSSPlugin.BUILD_MAP[moduleName]
            });
            write.asModule(pluginName + '!' + moduleName, 'define([\'vs/css!' + entryPoint + '\'], {});');
        };
        CSSPlugin.prototype.writeFile = function (pluginName, moduleName, req, write, config) {
            if (global.entryPoints && global.entryPoints.hasOwnProperty(moduleName)) {
                var fileName = req.toUrl(moduleName + '.css');
                var contents = [
                    '/*---------------------------------------------------------',
                    ' * Copyright (C) Microsoft Corporation. All rights reserved.',
                    ' *--------------------------------------------------------*/'
                ], entries = global.entryPoints[moduleName];
                for (var i = 0; i < entries.length; i++) {
                    contents.push(Utilities.rewriteUrls(entries[i].moduleName, moduleName, entries[i].contents));
                }
                write(fileName, contents.join('\r\n'));
            }
        };
        CSSPlugin.BUILD_MAP = {};
        return CSSPlugin;
    })();
    CSSLoaderPlugin.CSSPlugin = CSSPlugin;
    var Utilities = (function () {
        function Utilities() {
        }
        Utilities.startsWith = function (haystack, needle) {
            return haystack.length >= needle.length && haystack.substr(0, needle.length) === needle;
        };
        /**
         * Find the path of a file.
         */
        Utilities.pathOf = function (filename) {
            var lastSlash = filename.lastIndexOf('/');
            if (lastSlash !== -1) {
                return filename.substr(0, lastSlash + 1);
            }
            else {
                return '';
            }
        };
        /**
         * A conceptual a + b for paths.
         * Takes into account if `a` contains a protocol.
         * Also normalizes the result: e.g.: a/b/ + ../c => a/c
         */
        Utilities.joinPaths = function (a, b) {
            function findSlashIndexAfterPrefix(haystack, prefix) {
                if (Utilities.startsWith(haystack, prefix)) {
                    return Math.max(prefix.length, haystack.indexOf('/', prefix.length));
                }
                return 0;
            }
            var aPathStartIndex = 0;
            aPathStartIndex = aPathStartIndex || findSlashIndexAfterPrefix(a, '//');
            aPathStartIndex = aPathStartIndex || findSlashIndexAfterPrefix(a, 'http://');
            aPathStartIndex = aPathStartIndex || findSlashIndexAfterPrefix(a, 'https://');
            function pushPiece(pieces, piece) {
                if (piece === './') {
                    // Ignore
                    return;
                }
                if (piece === '../') {
                    var prevPiece = (pieces.length > 0 ? pieces[pieces.length - 1] : null);
                    if (prevPiece && prevPiece === '/') {
                        // Ignore
                        return;
                    }
                    if (prevPiece && prevPiece !== '../') {
                        // Pop
                        pieces.pop();
                        return;
                    }
                }
                // Push
                pieces.push(piece);
            }
            function push(pieces, path) {
                while (path.length > 0) {
                    var slashIndex = path.indexOf('/');
                    var piece = (slashIndex >= 0 ? path.substring(0, slashIndex + 1) : path);
                    path = (slashIndex >= 0 ? path.substring(slashIndex + 1) : '');
                    pushPiece(pieces, piece);
                }
            }
            var pieces = [];
            push(pieces, a.substr(aPathStartIndex));
            if (b.length > 0 && b.charAt(0) === '/') {
                pieces = [];
            }
            push(pieces, b);
            return a.substring(0, aPathStartIndex) + pieces.join('');
        };
        Utilities.commonPrefix = function (str1, str2) {
            var len = Math.min(str1.length, str2.length);
            for (var i = 0; i < len; i++) {
                if (str1.charCodeAt(i) !== str2.charCodeAt(i)) {
                    break;
                }
            }
            return str1.substring(0, i);
        };
        Utilities.commonFolderPrefix = function (fromPath, toPath) {
            var prefix = Utilities.commonPrefix(fromPath, toPath);
            var slashIndex = prefix.lastIndexOf('/');
            if (slashIndex === -1) {
                return '';
            }
            return prefix.substring(0, slashIndex + 1);
        };
        Utilities.relativePath = function (fromPath, toPath) {
            if (Utilities.startsWith(toPath, '/') || Utilities.startsWith(toPath, 'http://') || Utilities.startsWith(toPath, 'https://')) {
                return toPath;
            }
            // Ignore common folder prefix
            var prefix = Utilities.commonFolderPrefix(fromPath, toPath);
            fromPath = fromPath.substr(prefix.length);
            toPath = toPath.substr(prefix.length);
            var upCount = fromPath.split('/').length;
            var result = '';
            for (var i = 1; i < upCount; i++) {
                result += '../';
            }
            return result + toPath;
        };
        Utilities.rewriteUrls = function (originalFile, newFile, contents) {
            // Use ")" as the terminator as quotes are oftentimes not used at all
            return contents.replace(/url\(\s*([^\)]+)\s*\)?/g, function (_) {
                var matches = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    matches[_i - 1] = arguments[_i];
                }
                var url = matches[0];
                // Eliminate starting quotes (the initial whitespace is not captured)
                if (url.charAt(0) === '"' || url.charAt(0) === '\'') {
                    url = url.substring(1);
                }
                while (url.length > 0 && (url.charAt(url.length - 1) === ' ' || url.charAt(url.length - 1) === '\t')) {
                    url = url.substring(0, url.length - 1);
                }
                // Eliminate ending quotes
                if (url.charAt(url.length - 1) === '"' || url.charAt(url.length - 1) === '\'') {
                    url = url.substring(0, url.length - 1);
                }
                if (!Utilities.startsWith(url, 'data:') && !Utilities.startsWith(url, 'http://') && !Utilities.startsWith(url, 'https://')) {
                    var absoluteUrl = Utilities.joinPaths(Utilities.pathOf(originalFile), url);
                    url = Utilities.relativePath(newFile, absoluteUrl);
                }
                return 'url(' + url + ')';
            });
        };
        return Utilities;
    })();
    CSSLoaderPlugin.Utilities = Utilities;
    (function () {
        var cssLoader = null;
        var isAtomShell = (typeof process !== 'undefined' && typeof process.versions !== 'undefined' && typeof process.versions['atom-shell'] !== 'undefined');
        if (typeof process !== 'undefined' && process.versions && !!process.versions.node && !isAtomShell) {
            cssLoader = new NodeCSSLoader();
        }
        else if (navigator.userAgent.indexOf('MSIE 9') >= 0) {
            cssLoader = new IE9CSSLoader();
        }
        else if (navigator.userAgent.indexOf('MSIE 8') >= 0) {
            cssLoader = new IE8CSSLoader();
        }
        else {
            cssLoader = new BrowserCSSLoader();
        }
        define('vs/css', new CSSPlugin(cssLoader));
    })();
})(CSSLoaderPlugin || (CSSLoaderPlugin = {}));
/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
/// <reference path="declares.ts" />
/// <reference path="loader.ts" />
'use strict';
var TextLoaderPlugin;
(function (TextLoaderPlugin) {
    var BrowserTextLoader = (function () {
        function BrowserTextLoader() {
        }
        BrowserTextLoader.prototype.load = function (name, fileUrl, externalCallback, externalErrorback) {
            var req = new XMLHttpRequest();
            req.onreadystatechange = function () {
                if (req.readyState === 4) {
                    if ((req.status >= 200 && req.status < 300) || req.status === 1223 || (req.status === 0 && req.responseText && req.responseText.length > 0)) {
                        externalCallback(req.responseText);
                    }
                    else {
                        externalErrorback(req);
                    }
                    req.onreadystatechange = null;
                }
            };
            req.open('GET', fileUrl, true);
            req.responseType = '';
            req.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
            req.send(null);
        };
        return BrowserTextLoader;
    })();
    function readFileAndRemoveBOM(fs, path) {
        var BOM_CHAR_CODE = 65279;
        var contents = fs.readFileSync(path, 'utf8');
        // Remove BOM
        if (contents.charCodeAt(0) === BOM_CHAR_CODE) {
            contents = contents.substring(1);
        }
        return contents;
    }
    var NodeTextLoader = (function () {
        function NodeTextLoader() {
            this.fs = require.nodeRequire('fs');
        }
        NodeTextLoader.prototype.load = function (name, fileUrl, callback, errorback) {
            callback(readFileAndRemoveBOM(this.fs, fileUrl));
        };
        return NodeTextLoader;
    })();
    // ------------------------------ Finally, the plugin
    var TextPlugin = (function () {
        function TextPlugin(textLoader) {
            this.textLoader = textLoader;
        }
        TextPlugin.prototype.load = function (name, req, load, config) {
            config = config || {};
            var fileUrl = req.toUrl(name);
            this.textLoader.load(name, fileUrl, function (contents) {
                if (config.isBuild) {
                    TextPlugin.BUILD_MAP[name] = contents;
                }
                load(contents);
            }, function (err) {
                if (typeof load.error === 'function') {
                    load.error('Could not find ' + fileUrl);
                }
            });
        };
        TextPlugin.prototype.write = function (pluginName, moduleName, write) {
            if (TextPlugin.BUILD_MAP.hasOwnProperty(moduleName)) {
                var escapedText = Utilities.escapeText(TextPlugin.BUILD_MAP[moduleName]);
                write('define("' + pluginName + '!' + moduleName + '", function () { return "' + escapedText + '"; });');
            }
        };
        TextPlugin.BUILD_MAP = {};
        return TextPlugin;
    })();
    TextLoaderPlugin.TextPlugin = TextPlugin;
    var Utilities = (function () {
        function Utilities() {
        }
        /**
         * Escape text such that it can be used in a javascript string enclosed by double quotes (")
         */
        Utilities.escapeText = function (text) {
            // http://www.javascriptkit.com/jsref/escapesequence.shtml
            // \b	Backspace.
            // \f	Form feed.
            // \n	Newline.
            // \O	Nul character.
            // \r	Carriage return.
            // \t	Horizontal tab.
            // \v	Vertical tab.
            // \'	Single quote or apostrophe.
            // \"	Double quote.
            // \\	Backslash.
            // \ddd	The Latin-1 character specified by the three octal digits between 0 and 377. ie, copyright symbol is \251.
            // \xdd	The Latin-1 character specified by the two hexadecimal digits dd between 00 and FF.  ie, copyright symbol is \xA9.
            // \udddd	The Unicode character specified by the four hexadecimal digits dddd. ie, copyright symbol is \u00A9.
            var _backspace = '\b'.charCodeAt(0);
            var _formFeed = '\f'.charCodeAt(0);
            var _newLine = '\n'.charCodeAt(0);
            var _nullChar = 0;
            var _carriageReturn = '\r'.charCodeAt(0);
            var _tab = '\t'.charCodeAt(0);
            var _verticalTab = '\v'.charCodeAt(0);
            var _backslash = '\\'.charCodeAt(0);
            var _doubleQuote = '"'.charCodeAt(0);
            var startPos = 0, chrCode, replaceWith = null, resultPieces = [];
            for (var i = 0, len = text.length; i < len; i++) {
                chrCode = text.charCodeAt(i);
                switch (chrCode) {
                    case _backspace:
                        replaceWith = '\\b';
                        break;
                    case _formFeed:
                        replaceWith = '\\f';
                        break;
                    case _newLine:
                        replaceWith = '\\n';
                        break;
                    case _nullChar:
                        replaceWith = '\\0';
                        break;
                    case _carriageReturn:
                        replaceWith = '\\r';
                        break;
                    case _tab:
                        replaceWith = '\\t';
                        break;
                    case _verticalTab:
                        replaceWith = '\\v';
                        break;
                    case _backslash:
                        replaceWith = '\\\\';
                        break;
                    case _doubleQuote:
                        replaceWith = '\\"';
                        break;
                }
                if (replaceWith !== null) {
                    resultPieces.push(text.substring(startPos, i));
                    resultPieces.push(replaceWith);
                    startPos = i + 1;
                    replaceWith = null;
                }
            }
            resultPieces.push(text.substring(startPos, len));
            return resultPieces.join('');
        };
        return Utilities;
    })();
    TextLoaderPlugin.Utilities = Utilities;
    (function () {
        var textLoader = null;
        var isAtomShell = (typeof process !== 'undefined' && typeof process.versions !== 'undefined' && typeof process.versions['atom-shell'] !== 'undefined');
        if (typeof process !== 'undefined' && process.versions && !!process.versions.node && !isAtomShell) {
            textLoader = new NodeTextLoader();
        }
        else {
            textLoader = new BrowserTextLoader();
        }
        define('vs/text', new TextPlugin(textLoader));
    })();
})(TextLoaderPlugin || (TextLoaderPlugin = {}));
/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
/// <reference path="base/require.d.ts" />
'use strict';
define('vs/native', {
    load: function (name, parentRequire, onload, config) {
        var isAMD = true; // TODO@AMD
        if (isAMD) {
            var modulePath = name;
            parentRequire([modulePath], onload, onload.onError);
        }
        else {
            if (!self.MonacoEnvironment.appRoot) {
                onload.onError(new Error('missing appRoot'));
            }
            if (!self.require.__$__nodeRequire) {
                onload.onError(new Error('missing __$__nodeRequire'));
            }
            try {
                var value = self.require.__$__nodeRequire(self.MonacoEnvironment.appRoot + '/' + name);
            }
            catch (e) {
                onload.onError(e);
            }
            onload(value);
        }
    }
});
   /*!---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
/// <reference path="base/require.d.ts" />
'use strict';
define('vs/native', {
    load: function (name, parentRequire, onload, config) {
        var isAMD = true; // TODO@AMD
        if (isAMD) {
            var modulePath = name;
            parentRequire([modulePath], onload, onload.onError);
        }
        else {
            if (!self.MonacoEnvironment.appRoot) {
                onload.onError(new Error('missing appRoot'));
            }
            if (!self.require.__$__nodeRequire) {
                onload.onError(new Error('missing __$__nodeRequire'));
            }
            try {
                var value = self.require.__$__nodeRequire(self.MonacoEnvironment.appRoot + '/' + name);
            }
            catch (e) {
                onload.onError(e);
            }
            onload(value);
        }
    }
});
æ  /*!---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
(function(global) {

'use strict';

/* To test Daytona Resource support 
global.Plugin = {};
global.Plugin.Resources = {};
global.Plugin.Resources.getString = function (key, arg1, args2, args3) {
	return key;
};
*/

var Resources = global.Plugin && global.Plugin.Resources ? global.Plugin.Resources : undefined;

var DEFAULT_TAG = 'i-default';

function _format(message, args) {
    var result= message.replace(/\{(\d+)\}/g, function(match, rest) {
        var index= rest[0];
        return typeof args[index] !== 'undefined' ? args[index] : match;
    });
    if (self && self.document && self.document.URL.match(/[^\?]*\?[^\#]*pseudo=true/)) {
        // FF3B and FF3D is the Unicode zenkaku representation for [ and ]
        result= '\uFF3B' + result.replace(/[aouei]/g, '$&$&') + '\uFF3D';
    }
    return result;      
}

function findLanguageForModule(config, name) {
    var result = config[name];
    if (result)
        return result;
    result = config['*'];
    if (result)
        return result;
    return null; 
}


function localize(data, message) {
    var args = [];
    for (var _i = 0; _i < (arguments.length - 2); _i++) {
        args[_i] = arguments[_i+2];
    }
    return _format(message, args);
}

define('vs/nls', {
    load: function (name, req, load, config) {
		config = config || {};
        if (!name || name.length === 0 || config.isBuild) {
            load({
                localize: localize
            });
        } else  {
			var suffix;
			if (Resources) {
				suffix = '.nls.keys';
				req([name + suffix], function(keyMap) {
					load({
	                    localize: function(moduleKey, index) {
	                        if (!keyMap[moduleKey])
	                            return 'NLS error: unkown key ' + moduleKey;
	                        var mk = keyMap[moduleKey].keys;
	                        if (index >= mk.length)
	                            return 'NLS error unknow index ' + index;
							var subKey = mk[index];
	                        var args = [];
	                        args[0] = moduleKey + '_' + subKey;
	                        for (var _i = 0; _i < (arguments.length - 2); _i++) {
	                            args[_i + 1] = arguments[_i + 2];
	                        }
							return Resources.getString.apply(Resources, args);
						}
					});
				});
			} else {
	            var pluginConfig = config['vs/nls'] || {};
	            var language = pluginConfig.availableLanguages ? findLanguageForModule(pluginConfig.availableLanguages, name) : null;
	            suffix = '.nls';
	            if (language !== null && language !== DEFAULT_TAG) {
	                suffix = suffix + '.' + language;
	            }
	            
	            req([name + suffix], function(messages) {
	                load({
	                    localize: function(moduleKey, index) {
	                        var args = [];
	                        for (var _i = 0; _i < (arguments.length - 2); _i++) {
	                            args[_i] = arguments[_i+2];
	                        }
	                        if (!messages[moduleKey])
	                            return 'NLS error: unkown key ' + moduleKey;
	                        var mm = messages[moduleKey];
	                        if (index >= mm.length)
	                            return 'NLS error unknow index ' + index;
	                        return _format(mm[index], args);
	                    }
	                });
	            });
			}
        }
    },
    localize: localize
});

}(this));      Ï  /*!---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
/// <reference path="declares.ts" />
/// <reference path="loader.ts" />
'use strict';
var TextLoaderPlugin;
(function (TextLoaderPlugin) {
    var BrowserTextLoader = (function () {
        function BrowserTextLoader() {
        }
        BrowserTextLoader.prototype.load = function (name, fileUrl, externalCallback, externalErrorback) {
            var req = new XMLHttpRequest();
            req.onreadystatechange = function () {
                if (req.readyState === 4) {
                    if ((req.status >= 200 && req.status < 300) || req.status === 1223 || (req.status === 0 && req.responseText && req.responseText.length > 0)) {
                        externalCallback(req.responseText);
                    }
                    else {
                        externalErrorback(req);
                    }
                    req.onreadystatechange = null;
                }
            };
            req.open('GET', fileUrl, true);
            req.responseType = '';
            req.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
            req.send(null);
        };
        return BrowserTextLoader;
    })();
    function readFileAndRemoveBOM(fs, path) {
        var BOM_CHAR_CODE = 65279;
        var contents = fs.readFileSync(path, 'utf8');
        // Remove BOM
        if (contents.charCodeAt(0) === BOM_CHAR_CODE) {
            contents = contents.substring(1);
        }
        return contents;
    }
    var NodeTextLoader = (function () {
        function NodeTextLoader() {
            this.fs = require.nodeRequire('fs');
        }
        NodeTextLoader.prototype.load = function (name, fileUrl, callback, errorback) {
            callback(readFileAndRemoveBOM(this.fs, fileUrl));
        };
        return NodeTextLoader;
    })();
    // ------------------------------ Finally, the plugin
    var TextPlugin = (function () {
        function TextPlugin(textLoader) {
            this.textLoader = textLoader;
        }
        TextPlugin.prototype.load = function (name, req, load, config) {
            config = config || {};
            var fileUrl = req.toUrl(name);
            this.textLoader.load(name, fileUrl, function (contents) {
                if (config.isBuild) {
                    TextPlugin.BUILD_MAP[name] = contents;
                }
                load(contents);
            }, function (err) {
                if (typeof load.error === 'function') {
                    load.error('Could not find ' + fileUrl);
                }
            });
        };
        TextPlugin.prototype.write = function (pluginName, moduleName, write) {
            if (TextPlugin.BUILD_MAP.hasOwnProperty(moduleName)) {
                var escapedText = Utilities.escapeText(TextPlugin.BUILD_MAP[moduleName]);
                write('define("' + pluginName + '!' + moduleName + '", function () { return "' + escapedText + '"; });');
            }
        };
        TextPlugin.BUILD_MAP = {};
        return TextPlugin;
    })();
    TextLoaderPlugin.TextPlugin = TextPlugin;
    var Utilities = (function () {
        function Utilities() {
        }
        /**
         * Escape text such that it can be used in a javascript string enclosed by double quotes (")
         */
        Utilities.escapeText = function (text) {
            // http://www.javascriptkit.com/jsref/escapesequence.shtml
            // \b	Backspace.
            // \f	Form feed.
            // \n	Newline.
            // \O	Nul character.
            // \r	Carriage return.
            // \t	Horizontal tab.
            // \v	Vertical tab.
            // \'	Single quote or apostrophe.
            // \"	Double quote.
            // \\	Backslash.
            // \ddd	The Latin-1 character specified by the three octal digits between 0 and 377. ie, copyright symbol is \251.
            // \xdd	The Latin-1 character specified by the two hexadecimal digits dd between 00 and FF.  ie, copyright symbol is \xA9.
            // \udddd	The Unicode character specified by the four hexadecimal digits dddd. ie, copyright symbol is \u00A9.
            var _backspace = '\b'.charCodeAt(0);
            var _formFeed = '\f'.charCodeAt(0);
            var _newLine = '\n'.charCodeAt(0);
            var _nullChar = 0;
            var _carriageReturn = '\r'.charCodeAt(0);
            var _tab = '\t'.charCodeAt(0);
            var _verticalTab = '\v'.charCodeAt(0);
            var _backslash = '\\'.charCodeAt(0);
            var _doubleQuote = '"'.charCodeAt(0);
            var startPos = 0, chrCode, replaceWith = null, resultPieces = [];
            for (var i = 0, len = text.length; i < len; i++) {
                chrCode = text.charCodeAt(i);
                switch (chrCode) {
                    case _backspace:
                        replaceWith = '\\b';
                        break;
                    case _formFeed:
                        replaceWith = '\\f';
                        break;
                    case _newLine:
                        replaceWith = '\\n';
                        break;
                    case _nullChar:
                        replaceWith = '\\0';
                        break;
                    case _carriageReturn:
                        replaceWith = '\\r';
                        break;
                    case _tab:
                        replaceWith = '\\t';
                        break;
                    case _verticalTab:
                        replaceWith = '\\v';